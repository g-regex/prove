#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage[newfloat]{minted}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows.meta}
\usepackage{caption}

\definecolor{magnolia}{rgb}{0.97, 0.96, 1.0}
\setminted{
  bgcolor=magnolia,
}

\newcommand\prv{bc}
\newcommand\m[1]{\mintinline{\prv}{#1}}
\newcommand\cm[1]{\mintinline{c}{#1}}

\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Source-Code}

\newcommand\scref[1]{Source-Code \ref{code:#1}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\rightmargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style british
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\family typewriter
\shape smallcaps
[prove]
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This document is work in progress.
 All source code 
\begin_inset CommandInset citation
LatexCommand cite
key "[prove] GitHub repository"
literal "false"

\end_inset

 as well as the most recent version of this document 
\begin_inset CommandInset citation
LatexCommand cite
key "latest version of this file on GitHub"
literal "false"

\end_inset

 can be found on GitHub.
 The purpose of this document to introduce notation and vocabulary in order
 to facilitate efficient communication about this project.
 Underlying concepts are explained verbally and/or formally in order to
 detect any possible misconceptions of the matter.
 Furthermore this document could serve as an introduction to the project,
 if somebody wants to join.
 Especially with respect to this last point it might be useful to include
 a short discussion of the following points at the beginning of this document
 (this is a TODO list):
\end_layout

\begin_layout Itemize
a short verbal explanation of the purpose and form of the 
\family typewriter
\shape smallcaps
[prove]
\family default
\shape default
 language
\end_layout

\begin_layout Itemize
a list of terms we have agreed upon to describe certain entities, e.g.
 statement, formula, formulator, variable, constant, identifier, ...
 (we might have to have a look at our agreements again)
\end_layout

\begin_layout Itemize
to be continued ...
\end_layout

\begin_layout Standard
At the moment this document starts off right, where we ended our last discussion
, so no great explanations of things that we have agreed upon are present
 at the moment.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Terminology
\end_layout

\begin_layout Standard
In our last discussion, we have agreed on the following terminology:
\end_layout

\begin_layout Itemize
statement
\end_layout

\begin_layout Itemize
formula
\end_layout

\begin_layout Itemize
formulator
\end_layout

\begin_layout Standard
Further I would like to suggest the following terms.
 Some of the given explanations might be a bit confusing at this point,
 but their meaning will become clearer at a later point in this document.
\end_layout

\begin_layout Itemize
character (all legal characters, which are not square brackets)
\end_layout

\begin_layout Itemize
symbol (a concatenation of characters, delimited by square brackets or the
 end or the beginning of the file)
\end_layout

\begin_layout Itemize
identifier (every symbol, which is not a formulator)
\end_layout

\begin_layout Itemize
constant (an identifier, which is not allowed to be replaced by another
 identifier)
\end_layout

\begin_layout Itemize
variable (an identifier, which must be replaced by another identifier)
\end_layout

\begin_layout Itemize
constant statement (a statement, which is not comprised of any variables)
\end_layout

\begin_layout Itemize
implication (a formula only containing implication formulators)
\end_layout

\begin_layout Itemize
equality (a formula only containing equality formulators)
\end_layout

\begin_layout Itemize
ordinary formula (a formula, which contains no implication or equality symbols)
\end_layout

\begin_layout Itemize
known identifier (an identifier, which is a constant in the context of the
 currently processed statement)
\end_layout

\begin_layout Itemize
reachable constant (an identifier or a constant statement, which can be
 validated - i.e.
 is reachable when searching backwards in the graph representation of the
 proof - given all the known identifiers and constant statements in the
 context of the currently processed statement)
\end_layout

\begin_layout Itemize
backtracking (searching backwards in the graph - which is a special form
 of planar tree - for reachable constants)
\end_layout

\begin_layout Itemize
branch exploration (searching forwards for reachable constants in sub-branches,
 while backtracking)
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Syntax
\end_layout

\begin_layout Subsection
EBNF
\end_layout

\begin_layout Subsubsection
A first sketch
\end_layout

\begin_layout Standard
The syntax of the 
\family typewriter
\shape smallcaps
[prove]
\family default
\shape default
 language can conveniently be described by means of the extended Backus-Naur
 form
\begin_inset CommandInset citation
LatexCommand cite
key "EBNF Wikipedia page"
literal "false"

\end_inset

 (EBNF), which is a meta syntax notation defined in the ISO/IEC 14977 
\begin_inset CommandInset citation
LatexCommand cite
key "ISO/IEC 14977 standard"
literal "false"

\end_inset

 standard.
 Using an EBNF enables us to recursively and unambiguously describe nested
 patterns by grouping syntactic elements to so called 
\begin_inset Formula $\langle\texttt{production}\rangle$
\end_inset

s.
 It must always be possible to 
\begin_inset Quotes bld
\end_inset

unpack
\begin_inset Quotes brd
\end_inset

 a production in a unique and finite way, resulting in a (sequence of) 
\shape italic
terminal
\shape default
 symbols, indicated by quotation marks.
 In order to correctly interpret the 
\family typewriter
\shape smallcaps
[prove]
\family default
\shape default
-EBNF it is sufficient to understand the meaning of the following meta character
s:
\end_layout

\begin_layout Standard
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing double
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
indicates 
\begin_inset Quotes bld
\end_inset

or
\begin_inset Quotes brd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(\dots)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
groups productions and/or terminals together; only useful in combination
 with 
\begin_inset Formula $|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $[\dots]$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
indicates optionality
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\{\dots\}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
indicates zero or more repetitions
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
Using this notation the 
\family typewriter
\shape smallcaps
[prove]
\family default
\shape default
 language can be described by the following EBNF:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\langle\texttt{formula}\rangle & =\bigg\{\langle\texttt{statement}\rangle\langle\texttt{formulator}\rangle\Big|\langle\texttt{formulator}\rangle\langle\texttt{statement}\rangle\bigg\}\\
\langle\texttt{statement}\rangle & =\textrm{"["}\Big(\langle\texttt{formula}\rangle\Big|\langle\texttt{string}\rangle\Big|\langle\texttt{statement}\rangle\Big)\textrm{"]"}\bigg\{\textrm{"[" }\Big(\langle\texttt{formula}\rangle\Big|\langle\texttt{string}\rangle\Big|\langle\texttt{statement}\rangle\Big)\textrm{ "]" }\bigg\}\\
\langle\texttt{formulator\ensuremath{\rangle}} & =\textrm{"="\ensuremath{\Big|\texttt{"=>"}\Big|\langle\texttt{string\ensuremath{\rangle}}}}\\
\langle\texttt{symbol\ensuremath{\rangle}} & =\langle\texttt{character}\rangle\bigg\{\langle\texttt{character}\rangle\bigg\}\\
\langle\texttt{character\ensuremath{\rangle}} & =\Big(\textrm{"a"}\Big|\textrm{"b"}\Big|\dots\Big|\textrm{"z"}\Big|\textrm{"A"}\Big|\textrm{"B"}\Big|\dots\Big|\textrm{"Z"}\Big|\textrm{"0"}\Big|\textrm{"1"}\Big|\dots\Big|\textrm{"9"}\Big|\textrm{"+"\Big|\textrm{"-"}\Big|\textrm{"/"\Big|\textrm{"*"}\Big|\textrm{"\%"\Big|\textrm{"\textasciicircum"}\Big|\textrm{"\&"}\Big|\textrm{"."}\Big|\textrm{"?"}\Big|\textrm{"!"}}}}\Big)
\end{align*}

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Every EBNF needs to have an initial production as a starting point.
 It is convention that this distinguished production is to be listed first,
 so in this case, 
\begin_inset Formula $\langle\texttt{formula}\rangle$
\end_inset

 is the initial production.
 One might notice that a 
\begin_inset Formula $\langle\texttt{formula}\rangle$
\end_inset

 might be empty and a 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

 may contain such an empty 
\begin_inset Formula $\langle\texttt{formula}\rangle$
\end_inset

.
 We can reason about whether this makes sense or not, and it might be necessary
 to revise these definitions, but currently I just regard these situations
 as edge cases with no harmful implications.
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
Examples
\end_layout

\begin_layout Standard
Here are some examples of productions and some motivations for the design
 of the syntax.
 We will work our way up from bottom to top through the EBNF.
\end_layout

\begin_layout Itemize
A 
\begin_inset Formula $\langle\texttt{symbol}\rangle$
\end_inset

 can be any letter, number or one of the 10 special characters as indicated
 in the EBNF.
 Examples of valid 
\begin_inset Formula $\langle\texttt{symbol}\rangle$
\end_inset

s are 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{a}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{T}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{7}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{&}
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
A 
\begin_inset Formula $\langle\texttt{string}\rangle$
\end_inset

 is a sequence of one or more symbols.
 Examples of valid 
\begin_inset Formula $\langle\texttt{string}\rangle$
\end_inset

s are: 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{a7we}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{T}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{76}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{&q}
\end_layout

\end_inset

.
 Note that 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{T}
\end_layout

\end_inset

 is a 
\begin_inset Formula $\langle\texttt{string}\rangle$
\end_inset

 and a 
\begin_inset Formula $\langle\texttt{symbol}\rangle$
\end_inset

 at the same time.
 This does not mean that the grammar is ambiguous.
 A single 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{T}
\end_layout

\end_inset

 will always be interpreted in this way, but it depends on the context,
 whether we are interested in the fact of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{T}
\end_layout

\end_inset

 being a 
\begin_inset Formula $\langle\texttt{string}\rangle$
\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{T}
\end_layout

\end_inset

 being a 
\begin_inset Formula $\langle\texttt{symbol}\rangle$
\end_inset

.
\end_layout

\begin_layout Itemize
A 
\begin_inset Formula $\langle\texttt{formulator}\rangle$
\end_inset

 is either a 
\begin_inset Formula $\langle\texttt{string}\rangle$
\end_inset

 or any one of the terminals 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=}
\end_layout

\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=>}
\end_layout

\end_inset

.
 Examples of valid 
\begin_inset Formula $\langle\texttt{formulator}\rangle$
\end_inset

s are 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{a7we}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{T}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=>}
\end_layout

\end_inset

.
 Note that 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=T}
\end_layout

\end_inset

 is not a valid 
\begin_inset Formula $\langle\texttt{formulator}\rangle$
\end_inset

.
 Seeing that 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{T}
\end_layout

\end_inset

 can be a 
\begin_inset Formula $\langle\texttt{formulator}\rangle$
\end_inset

 (comprised of a 
\begin_inset Formula $\langle\texttt{string}\rangle$
\end_inset

) in one case and just a 
\begin_inset Formula $\langle\texttt{string}\rangle$
\end_inset

 (not packed inside a 
\begin_inset Formula $\langle\texttt{formulator}\rangle$
\end_inset

) in another case, one might worry about ambiguity.
 However, having a close look at the EBNF, we see that 
\begin_inset Formula $\langle\texttt{formulator}\rangle$
\end_inset

s only occur in between 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

s and 
\begin_inset Formula $\langle\texttt{string}\rangle$
\end_inset

s only within 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

s.
 The user of the language has great freedom in naming formulators and identifier
s (TODO: define formulators and identifiers in this document, i.e.
 not the productions, but what they represent), so it is up to the user
 to choose them wisely.
 It could for example be confusing to name a formulator 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{7}
\end_layout

\end_inset

, but 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{add7}
\end_layout

\end_inset

 makes intuitively sense.
\end_layout

\begin_layout Itemize
A 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

 is a concatenation of one or more pairs of square brackets each containing
 either a 
\begin_inset Formula $\langle\texttt{formula}\rangle$
\end_inset

, a 
\begin_inset Formula $\langle\texttt{string}\rangle$
\end_inset

 or a 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

.
 Examples of valid 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

s are 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[]}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[a][b][[a]in[b]]}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[[]]}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[[a]or[b]]}
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
A 
\begin_inset Formula $\langle\texttt{formula}\rangle$
\end_inset

 is comprised of at least one 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

 and at least one 
\begin_inset Formula $\langle\texttt{formulator}\rangle$
\end_inset

.
 The order of occurrence does not matter.
 Examples of valid 
\begin_inset Formula $\langle\texttt{formula}\rangle$
\end_inset

e are 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[a]in[b]}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[a]=[b][c]}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[[a]a7we[b]]=>[c]}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Improving the sketch (and second thoughts on this improvement)
\end_layout

\begin_layout Standard
As intuitive and beautiful (due to its simplicity) this first sketch might
 look, there are a few problems with it.
 Firstly a proof might be given in form of a statement or in form of a formula.
 Secondly, when parsing a 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

 we might have to look far ahead after encountering the leading 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[}
\end_layout

\end_inset

 in order to determine, whether we are handling a 
\begin_inset Formula $\langle\texttt{formula}\rangle$
\end_inset

 or a 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

.
 One way to address this issue is, to start parsing a 
\begin_inset Formula $\langle\texttt{formula}\rangle$
\end_inset

, after reading a 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[}
\end_layout

\end_inset

, but then, when not finding a 
\begin_inset Formula $\langle\texttt{formulator}\rangle$
\end_inset

, not to report an error, but to proceed with the steps that would follow
 when parsing a statement.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset

To encode this behaviour in the EBNF and to address the issue of having
 the proof as a whole in form of a statement or a formula, we can introduce
 a helper production 
\begin_inset Formula $\langle\texttt{expr}\rangle$
\end_inset

(for expression) containing either a 
\begin_inset Formula $\langle\texttt{formula}\rangle$
\end_inset

 or a 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
\langle\texttt{expr}\rangle & =\langle\texttt{statement}\rangle\Big|\langle\texttt{formula}\rangle\\
\langle\texttt{formula}\rangle & =\bigg\{\langle\texttt{statement}\rangle\langle\texttt{formulator}\rangle\Big|\langle\texttt{formulator}\rangle\langle\texttt{statement}\rangle\bigg\}\\
\langle\texttt{statement}\rangle & =\textrm{"["}\Big(\langle\texttt{expr}\rangle\Big|\langle\texttt{string}\rangle\Big)\textrm{"]"}\bigg\{\textrm{"[" }\Big(\langle\texttt{expr}\rangle\Big|\langle\texttt{string}\rangle\Big)\textrm{ "]" }\bigg\}\\
\langle\texttt{formulator\ensuremath{\rangle}} & =\textrm{"="\ensuremath{\Big|\texttt{"=>"}\Big|\langle\texttt{string\ensuremath{\rangle}}}}\\
\langle\texttt{symbol\ensuremath{\rangle}} & =\langle\texttt{character}\rangle\bigg\{\langle\texttt{character}\rangle\bigg\}\\
\langle\texttt{character\ensuremath{\rangle}} & =\Big(\textrm{"a"}\Big|\textrm{"b"}\Big|\dots\Big|\textrm{"z"}\Big|\textrm{"A"}\Big|\textrm{"B"}\Big|\dots\Big|\textrm{"Z"}\Big|\textrm{"0"}\Big|\textrm{"1"}\Big|\dots\Big|\textrm{"9"}\Big|\textrm{"+"\Big|\textrm{"-"}\Big|\textrm{"/"\Big|\textrm{"*"}\Big|\textrm{"\%"\Big|\textrm{"\textasciicircum"}\Big|\textrm{"\&"}\Big|\textrm{"."}\Big|\textrm{"?"}\Big|\textrm{"!"}}}}\Big)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Second thoughts: It might be worth considering to disallow proofs to be
 given in form of a statement.
 When it comes to 
\shape italic
verification, 
\shape default
we will see that it makes a difference, whether a formula stands 
\begin_inset Quotes bld
\end_inset

freely
\begin_inset Quotes brd
\end_inset

 or whether it is inside an assumed statement and might not require verification.
 Considering a free standing statement as an assumption would than render
 the whole proof as an assumption and prohibit its verification.
\end_layout

\begin_layout Section
Scanning and Parsing
\end_layout

\begin_layout Standard
When processing a 
\family typewriter
\shape smallcaps
[prove]
\family default
\shape default
 source file, we first convert the stream of characters the source file
 is comprised of to a stream of tokens, which have a meaning in the context
 of the grammar.
 The tokens can be enumerated by the following (quite self-explanatory)
 definition in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{token.h}
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos]{c}
\end_layout

\begin_layout Plain Layout

typedef enum {
\end_layout

\begin_layout Plain Layout

    TOK_EOF,     /* end-of-file */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    TOK_LBRACK,  /* left bracket */
\end_layout

\begin_layout Plain Layout

    TOK_RBRACK,  /* right bracket */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    TOK_IMPLY,   /* implication */
\end_layout

\begin_layout Plain Layout

    TOK_EQ,      /* equality */
\end_layout

\begin_layout Plain Layout

    TOK_SYM      /* symbol */
\end_layout

\begin_layout Plain Layout

} TType;
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This token stream is fed to the parser, which then validates the adherence
 to the EBNF as given above.
 Inside the parser functions, which are validating the syntactic correctness
 of the source file, further function calls and checks for semantic correctness
 and mathematical correctness will take place.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Semantic
\end_layout

\begin_layout Standard
When generating a couple of syntactically correct snippets of 
\family typewriter
\shape smallcaps
[prove]
\family default
\shape default
 code, one realises that not all code adhering to the rules of the EBNF
 makes sense - at least not without introducing more conventions.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Consider the following code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{minted}{
\backslash
prv}
\end_layout

\begin_layout Plain Layout

[a]and[b]=[c]=>[b][c]
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The use of 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=}
\end_layout

\end_inset

 and 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=>}
\end_layout

\end_inset

 is ambiguous in this context, since 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=}
\end_layout

\end_inset

 could refer to everything on its right hand side or just to 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[c]}
\end_layout

\end_inset

.
 Similarly 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=>}
\end_layout

\end_inset

 could refer to everything to its left hand side or just to 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{[c]}
\end_layout

\end_inset

.
 This problem could be addressed by introducing an order of precedence (e.g.
 non reserved formulators, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=>}
\end_layout

\end_inset

).
 However, the implications of this approach should be carefully considered.
 Precedence can easily be encoded in the EBNF, without changing the set
 of valid code patterns.
 By doing so we could elegantly encode a part of the language's meaning
 in its syntactic structure.
 As tempting as this idea might be, I can see a negative side effect coming
 along with this approach.
 Introducing precedence between formulators will set brackets 
\shape italic
implicitly.
 
\shape default
Since the visibility and meaning of identifiers (variables/constants)
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
define identifiers
\end_layout

\end_inset

 depends on the depth of nesting of statements (i.e.
 on brackets), the approach of precedence might lead to counter-intuitive
 code.
 Therefore I recommend against the precedence approach.
 
\end_layout

\begin_layout Standard
Instead I suggest the following semantic rule, which will address this issue:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=}
\end_layout

\end_inset

, 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=>}
\end_layout

\end_inset

 and other formulators must not be mixed
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Consider the following code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}{
\backslash
prv}
\end_layout

\begin_layout Plain Layout

[a][b]=>[c]
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Translated to English this means 
\begin_inset Quotes bld
\end_inset

Let a and b be identifiers, then we have an identifier c
\begin_inset Quotes brd
\end_inset

.
 We do not know, where c comes from, since it was not introduced before.
 Therefore I suggest the following rule (we will see in the proof of Russell's
 paradox that we might have to relax this rule a little bit, when dealing
 with equalities):
\end_layout

\begin_layout Itemize
new identifiers must only be introduced before the first 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=>}
\end_layout

\end_inset

 in a formula
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset

Further I suggest the following rule for obvious reasons:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=>}
\end_layout

\end_inset

 must not appear at the end of a 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset


\end_layout

\begin_layout Standard
Side note: Every formula, involving formulators other than 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=}
\end_layout

\end_inset

 or 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
m{=>}
\end_layout

\end_inset

 and comprised of 
\begin_inset Formula $n$
\end_inset

 statements, can be viewed as an 
\begin_inset Formula $n$
\end_inset

-ary operator.
 In that sense single identifiers are formulae as well, defining a nullary
 operation.
 Maybe it is not necessary to make a difference between formulators and
 identifiers.
 One argument against that would be though that formulators never function
 as variables - well..
 maybe they can (think of isomorphisms).
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Representation
\end_layout

\begin_layout Subsection
Example: Russell's Paradox
\end_layout

\begin_layout Standard
A first example, we considered, is the following proof of Russell's Paradox.
 The purpose of this 
\family typewriter
\shape smallcaps
[prove]
\family default
\shape default
 code is to provide a valid proof as a starting point for investigating
 further, which rules a data type representation should follow and which
 properties it must have.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{code}
\end_layout

\begin_layout Plain Layout


\backslash
captionof{listing}{Russels Paradox}
\end_layout

\begin_layout Plain Layout


\backslash
label{code:russell}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos]{
\backslash
prv}
\end_layout

\begin_layout Plain Layout

[A] [ [x] => [ [[x]in[A]] = [[[x]in[x]]=>[False]] ] ] =>
\end_layout

\begin_layout Plain Layout

[ [A] => [[[A]in[A]] = [[[A]in[A]]=>[False]]] ] =>
\end_layout

\begin_layout Plain Layout

[ [[A]in[A]] = [[[A]in[A]]=>[False]] ] =>
\end_layout

\begin_layout Plain Layout

[ [[A]in[A]] =>
\end_layout

\begin_layout Plain Layout

	[[[A]in[A]]=>[False]] =>
\end_layout

\begin_layout Plain Layout

	[False]] =>
\end_layout

\begin_layout Plain Layout

[ [[A]in[A]] =>
\end_layout

\begin_layout Plain Layout

[False]] =>
\end_layout

\begin_layout Plain Layout

[ [A]in[A] ] =>
\end_layout

\begin_layout Plain Layout

[False] 
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{code}
\end_layout

\end_inset

In the following subsections, we will showcase a possible representation
 of the structure of this proof as a graph and the C implementation of this
 graph.
\end_layout

\begin_layout Subsection
Graph representation
\end_layout

\begin_layout Standard
An intuitive approach for representing the structure of this proof is by
 means of a graph (in particular a special planar tree).
\end_layout

\begin_layout Subsubsection
Nodes
\end_layout

\begin_layout Standard
Every graph is comprised of a set of nodes.
 The nodes used in the current realisation of the 
\family typewriter
\shape smallcaps
[prove]
\family default
\shape default
 software, are represented by the following structure, which can be found
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{pgraph.h}
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos]{c}
\end_layout

\begin_layout Plain Layout

typedef struct Pnode {
\end_layout

\begin_layout Plain Layout

	struct Pnode* parent;
\end_layout

\begin_layout Plain Layout

	struct Pnode* child;
\end_layout

\begin_layout Plain Layout

	struct Pnode* left;
\end_layout

\begin_layout Plain Layout

	struct Pnode* right;
\end_layout

\begin_layout Plain Layout

	struct Pnode* prev_const;/* link to previous constant in the tree */
\end_layout

\begin_layout Plain Layout

	char** symbol; /* using a double pointer to let known identifiers
\end_layout

\begin_layout Plain Layout

					  point to the same char* in memory */
\end_layout

\begin_layout Plain Layout

	NFlags flags;
\end_layout

\begin_layout Plain Layout

	int num; /* number of the current node in pre-order traversal of the tree
 */
\end_layout

\begin_layout Plain Layout

	Variable* var; /* link to the first variable in
\end_layout

\begin_layout Plain Layout

					  sub-tree (for substitution) */
\end_layout

\begin_layout Plain Layout

} Pnode;
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The nodes are each doubly linked the nodes adjacent to them in order to
 enable us to navigate through the graph.
 Every pair of brackets is represented as a node.
 During the creation of the graph nodes are created as children or to the
 right of the current node.
 When encountering an opening bracket, a child-node is created and the child
 becomes the current node.
 When a closing bracket is encountered, we move leftwards through the nodes
 as far as possible and then to the parent node.
 When encountering the next opening bracket, we check whether the current
 node has already children and if so, we create a node to the right of the
 current one and move to it, before creating a new child node.
\end_layout

\begin_layout Subsubsection
Graph
\end_layout

\begin_layout Standard
Using the previously introduced nodes and applying the rules for the creation
 of the graph to Russell's Paradox (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
scref{russell}
\end_layout

\end_inset

), we can create the following graph:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{Graph representation of 
\backslash
scref{russell}}
\end_layout

\begin_layout Plain Layout


\backslash
label{russell_graph}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "graph.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Flags
\end_layout

\begin_layout Subsubsection
NFLAGs
\end_layout

\begin_layout Standard
For the later verification of the proof it is useful to store all necessary
 information about each node in the corresponding structure.
 We can do this by means of flags, which are integer values of powers of
 
\begin_inset Formula $2$
\end_inset

.
 Using bitwise binary operators these flags can be set and unset for each
 node respectively.
 The enumeration defining the node specific flags (NFLAGs) can be found
 in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{pgraph.h}
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos]{c}
\end_layout

\begin_layout Plain Layout

typedef enum {
\end_layout

\begin_layout Plain Layout

	NFLAG_NONE = 0,
\end_layout

\begin_layout Plain Layout

	NFLAG_IMPL = 1,
\end_layout

\begin_layout Plain Layout

	NFLAG_EQTY = 2,
\end_layout

\begin_layout Plain Layout

	NFLAG_FMLA = 4,
\end_layout

\begin_layout Plain Layout

	NFLAG_ASMP = 8,
\end_layout

\begin_layout Plain Layout

	NFLAG_LOCK = 16,
\end_layout

\begin_layout Plain Layout

	NFLAG_NEWC = 32,
\end_layout

\begin_layout Plain Layout

	NFLAG_FRST = 64
\end_layout

\begin_layout Plain Layout

} NFlags;
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For convenience we say that a node is an assumption, if the child statement
 or formula is an assumption.
 The flags have the following meaning:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Flag
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meaning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IMPL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The node is part of a formula, containing implication formulators.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EQTY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The node is part of a formula, containing equality formulators.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FMLA
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The node is part of an ordinary formula.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASMP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The node is an assumption (only of interest in implications).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LOCK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The ASMP flag is 
\begin_inset Quotes bld
\end_inset

locked
\begin_inset Quotes brd
\end_inset

, i.e.
 all nodes at lower levels are also assumptions.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NEWC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The node contains a newly introduced constant (identifier).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FRST
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The node appears before the first formulator in a formula.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note that only certain combinations of NFLAGs can occur.
 For example at most one of the flags IMPL, EQTY and FMLA must be set.
 Furthermore some flags might be set or unset in certain context, where
 they do not make sense, but they are not of interest.
\end_layout

\begin_layout Standard
For example:
\end_layout

\begin_layout Itemize
The FRST flag might be set or unset in a node, which is part of a statement.
 Since the FRST flag is only of interest in a formula, we disregard this
 setting to keep the code simple.
\end_layout

\begin_layout Itemize
The ASMP flag is set for all statements occurring before the first formulator,
 since the first statement in an implication is an assumption.
 It is also set in ordinary formulae, but we disregard it.
\end_layout

\begin_layout Standard
One important fact about the ASMP flag is that it 
\begin_inset Quotes bld
\end_inset

trickles down
\begin_inset Quotes brd
\end_inset

 the tree, i.e.
 if a node has the ASMP flag set, then its children will also have the ASMP
 flag set.
 This behaviour is ensured by the LOCK flag.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsubsection
GFLAGs
\end_layout

\begin_layout Standard
When traversing the graph at a later stage for verification, we might want
 to store the current state of the graph during this process.
 This state is not specific to any node, but to the graph as a whole.
 We can therefore call the flags used for this purpose GFLAGs.
 Their definition can also be found in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{pgraph.h}
\end_layout

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos]{c}
\end_layout

\begin_layout Plain Layout

typedef enum {
\end_layout

\begin_layout Plain Layout

	GFLAG_NONE = 0,
\end_layout

\begin_layout Plain Layout

	GFLAG_VRFD = 1,
\end_layout

\begin_layout Plain Layout

	GFLAG_SUBD = 2,
\end_layout

\begin_layout Plain Layout

	GFLAG_BRCH = 4,
\end_layout

\begin_layout Plain Layout

	GFLAG_WRAP = 8
\end_layout

\begin_layout Plain Layout

} GFlags;
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The flags have the following meaning:
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Flag
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Meaning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VRFD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The last statement at a lower level was verified (no further verification
 required).
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SUBD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A variable in the currently processed branch has been substituted.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BRCH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A branch in currently traversed.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WRAP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nodes in a formula 
\begin_inset Quotes bld
\end_inset

wrap around
\begin_inset Quotes brd
\end_inset

 when moving rightwards (useful for equalities).
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Differences between implication and equality
\end_layout

\begin_layout Standard
This subsection requires some more investigation and discussion.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
m{=>}
\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
m{=}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
New identifiers become variables at parent level.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
New identifiers are unknown at parent level.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unidirectional
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
bidirectional
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Variables and constants
\end_layout

\begin_layout Standard
Identifiers can be either variables, constants or unknown depending on the
 context (i.e.
 the node from whose perspective we intend to make use of that identifier).
 In the following, we will say that a node is 
\emph on
below
\emph default
 another node, when it is its child or below its child.
 Further we will say that a node is a 
\emph on
younger sibling
\emph default
 of another node, if it is right of that node or right of a younger sibling
 of that node.
 We can now define the following:
\end_layout

\begin_layout Itemize
An identifier is a constant for all nodes, which are below the younger siblings
 of the parent node of the identifier.
\end_layout

\begin_layout Itemize
An identifier is a variable for all nodes, which are below the younger siblings
 of the parent node of the parent node of the identifier.
\end_layout

\begin_layout Itemize
An identifier is unknown for every other node.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Verification
\end_layout

\begin_layout Standard
Each statement potentially has to be verified.
 Since some statements are assumptions and others are just a part of an
 ordinary formula, we have to decide, which statements we have to verify
 and which not to.
 A reasonable approach seems to only verify implications, which are not
 assumptions (equalities are a bit tricky - this might require some more
 discussion).
 Following this idea, we can trigger verification at the end of the parse
 function for a 
\begin_inset Formula $\langle\texttt{statement}\rangle$
\end_inset

 in 
\family typewriter
pparser.c (
\family default
the code has been stripped of the debugging output to improve its readability):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos]{c}
\end_layout

\begin_layout Plain Layout

/* verification is triggered here */
\end_layout

\begin_layout Plain Layout

if (HAS_NFLAG_IMPL(pnode) && !HAS_NFLAG_ASMP(pnode)) {
\end_layout

\begin_layout Plain Layout

	init_reachable(pnode);
\end_layout

\begin_layout Plain Layout

	while (next_reachable_const(pnode)) {
\end_layout

\begin_layout Plain Layout

		if(same_as_rchbl(pnode)) {
\end_layout

\begin_layout Plain Layout

			SET_GFLAG_VRFD
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
What happens here is the following:
\end_layout

\begin_layout Itemize
The current node (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cm{pnode}
\end_layout

\end_inset

) is checked for having the IMPL flag set and the ASMP flag unset.
\end_layout

\begin_layout Itemize
In line 3 the verification is initialised.
\end_layout

\begin_layout Itemize
From line 4 to line 8, we loop through all nodes, which are reachable from
 the perspective of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cm{pnode}
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
If the current node is similar (TODO: define this properly - but for now
 it's quite obvious) to the reachable node currently inspected (line 5),
 then set the VRFD global flag.
\end_layout

\begin_layout Standard
The core of this verification lies in the function in the following function,
 which can be found in 
\family typewriter
pgraph.h
\family default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{code}
\end_layout

\begin_layout Plain Layout


\backslash
captionof{listing}{next reachable constant statement}
\end_layout

\begin_layout Plain Layout


\backslash
label{code:next_reachable}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos]{c}
\end_layout

\begin_layout Plain Layout

unsigned short int next_reachable_const(Pnode* pnode) {
\end_layout

\begin_layout Plain Layout

	/* branch exploration */
\end_layout

\begin_layout Plain Layout

	if (HAS_GFLAG_BRCH) {
\end_layout

\begin_layout Plain Layout

		if (!next_in_branch(pnode)) {
\end_layout

\begin_layout Plain Layout

			exit_branch();
\end_layout

\begin_layout Plain Layout

			UNSET_GFLAG_BRCH
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		return TRUE;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* substitution */
\end_layout

\begin_layout Plain Layout

	if (HAS_GFLAG_SUBD){
\end_layout

\begin_layout Plain Layout

		if (next_known_id()) {
\end_layout

\begin_layout Plain Layout

			sub_vars();
\end_layout

\begin_layout Plain Layout

			return attempt_explore(pnode);
\end_layout

\begin_layout Plain Layout

		} else {
\end_layout

\begin_layout Plain Layout

			finish_sub();
\end_layout

\begin_layout Plain Layout

			return next_reachable_const(pnode);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/* backtracking */
\end_layout

\begin_layout Plain Layout

	if (move_left(&reachable) ||
\end_layout

\begin_layout Plain Layout

 			(move_up(&reachable) && move_left(&reachable))) {
\end_layout

\begin_layout Plain Layout

		if (HAS_SYMBOL(reachable) ?  move_left(&reachable) :  TRUE) {
\end_layout

\begin_layout Plain Layout

			if (reachable->var != NULL) {
\end_layout

\begin_layout Plain Layout

				init_sub(pnode);
\end_layout

\begin_layout Plain Layout

				sub_vars();
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			return attempt_explore(pnode);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	return FALSE;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{code}
\end_layout

\end_inset

The verification can be subdivided into three steps: backtracking, substitution
 and branch exploration.
 Each of these steps work on a pointer 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cm{reachable}
\end_layout

\end_inset

 pointing to the potentially next reachable node.
\end_layout

\begin_layout Subsection
Backtracking
\end_layout

\begin_layout Standard
During backtracking 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cm{reachable}
\end_layout

\end_inset

 moves leftwards and upwards in the tree (there is always only one of these
 options available) skipping all formulators on the way.
 After each move it is determined, whether the node contains any variables.
 If so, substitution is initialised.
 Next an attempt to explore the branch (the subtree below the node pointed
 to by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cm{reachable}
\end_layout

\end_inset

) is started.
 If it is unsuccessful, the next reachable node has been found.
 Otherwise branch exploration is started.
\end_layout

\begin_layout Subsection
Substitution
\end_layout

\begin_layout Standard
If during backtracking it was determined that substitution is needed, we
 loop through all known identifiers and substitute each of them into the
 node currently pointed to by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cm{reachable}
\end_layout

\end_inset

.
 For each substituted identifier an attempt of branch exploration is started.
\end_layout

\begin_layout Subsection
Branch exploration
\end_layout

\begin_layout Standard
A branch is said to be explorable, if the assumptions 
\begin_inset Quotes bld
\end_inset

guarding
\begin_inset Quotes brd
\end_inset

 (I like this word, maybe it should be introduced to the terminology) the
 branch are satisfied by any of the known constant statements.
 In that case the branch is traversed in the opposite direction as during
 backtracking.
 Every statement in the branch not depending on an unsatisfied assumption
 is then reachable.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Output
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{node numbers in pre-order traversal of figure 
\backslash
ref{russell_graph}}
\end_layout

\begin_layout Plain Layout


\backslash
label{russell_preorder}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "graph_pot.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{code}
\end_layout

\begin_layout Plain Layout


\backslash
captionof{listing}{
\backslash
texttt{[prove]} output after processing 
\backslash
scref{russell}}
\end_layout

\begin_layout Plain Layout


\backslash
label{code:russell_output}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos]{
\backslash
prv}
\end_layout

\begin_layout Plain Layout

[A][[x]=>[[[x]in[A]]=[[[x]in[x]]=>[False]]]]=>
\end_layout

\begin_layout Plain Layout

[[A]=>
\end_layout

\begin_layout Plain Layout

	[[[A]in[A]]=[[[A]in[A]]=>[False]]]{29}<26><6#><2><6#><2><0>]*{25}<6><2#><0>=>
\end_layout

\begin_layout Plain Layout

[[[A]in[A]]=[[[A]in[A]]=>[False]]]{48}<29#><25><6#><2><0>=>
\end_layout

\begin_layout Plain Layout

[[[A]in[A]]=>
\end_layout

\begin_layout Plain Layout

	[[[A]in[A]]=>
\end_layout

\begin_layout Plain Layout

		[False]{83}<76><68><56><64#><49><48><29><37><45#><30><25><6><14><22#><7><2>
\end_layout

\begin_layout Plain Layout

		<0>]*{75}<68><56#><64><49><48><29><37#><45><30><25><6><14#><22><7><2><0>=>
\end_layout

\begin_layout Plain Layout

	[False]{86}<83#><75><68><56><64#><49><48><29><37><45#>
\end_layout

\begin_layout Plain Layout

	<30><25><6><14><22#><7><2><0>]*{67}<29><25><6><2><0>=>
\end_layout

\begin_layout Plain Layout

[[[A]in[A]]=>
\end_layout

\begin_layout Plain Layout

	[False]{97}<90><75><83#><86#><67><56><64#><49><48><29><37><45#>
\end_layout

\begin_layout Plain Layout

	<30><25><6><14><22#><7><2><0>]*{89}<49><56#><48><29><30><37#><25><6><7><14#><2>
<0>=>
\end_layout

\begin_layout Plain Layout

[[A]in[A]]{100}<49#><56><48><29><30#><37><25><6><7#><14><2><0>=>
\end_layout

\begin_layout Plain Layout

[False]{107}<100><97#><89><75><83#><86#><67><56><64#>
\end_layout

\begin_layout Plain Layout

<49><48><29><37><45#><30><25><6><14><22#><7><2><0>
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{code}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Currently the 
\family typewriter
\shape smallcaps
[prove]
\family default
\shape default
 software produces hardly more than debugging output.
 It can be very helpful though for understanding the process of verification.
 To refer to the nodes of the graph, the nodes are numbered in pre-order
 traversal 
\begin_inset CommandInset citation
LatexCommand cite
key "pre-order traversal"
literal "false"

\end_inset

 as illustrated in figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{russell_preorder}
\end_layout

\end_inset

.
 The corresponding output (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
scref{russell_output}
\end_layout

\end_inset

 [some line breaks have been added to improve readibility]) can be understood
 as follows:
\end_layout

\begin_layout Itemize
When verifying a node, 
\family typewriter
\shape smallcaps
[prove]
\family default
\shape default
 prints the number of the node within curly braces (e.g.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
m{{83}}
\end_layout

\end_inset

).
\end_layout

\begin_layout Itemize
The number of every reachable node that the node to be verified is checked
 against is printed within angle brackets (e.g.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
m{<76>}
\end_layout

\end_inset

).
\end_layout

\begin_layout Itemize
If the verification was successful, a hash is added to the number of the
 reachable node (e.g.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{<64
\backslash
#>}
\end_layout

\end_inset

).
\end_layout

\begin_layout Itemize
If verification of the current node is not necessary, because the VRFD flag
 is set, a star is printed before the node number (e.g.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
m{*{67}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Currently no verification steps are skipped and nodes are often verified
 multiple times.
 This is desired at the current stage for debugging purposes and to illustrate
 the underlying verification mechanism.
\end_layout

\begin_layout Standard
Most semantic rules are also still not checked and some of them still have
 to be defined.
 One very important issue, which I would like to discuss, is how identifiers
 are allowed to be introduced.
 For the verification of this proof I had to relax a few restrictions that
 I have originally imposed on this issue, but without further elaboration
 of this, I suggest a proper discussion of the matter.
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "[prove] GitHub repository"
literal "false"

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "https://github.com/g-regex/prove"
target "https://github.com/g-regex/prove"
literal "false"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "latest version of this file on GitHub"
literal "false"

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "https://github.com/g-regex/prove/blob/master/doc/doc.pdf"
target "https://github.com/g-regex/prove/blob/master/doc/doc.pdf"
literal "false"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "EBNF Wikipedia page"
literal "false"

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"
target "https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"
literal "false"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "ISO/IEC 14977 standard"
literal "false"

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "https://www.cl.cam.ac.uk/~mgk25/iso-14977.pdf"
target "https://www.cl.cam.ac.uk/~mgk25/iso-14977.pdf"
literal "false"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "BNF Wikipedia page"
literal "false"

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form"
target "https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form"
literal "false"

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "pre-order traversal"
literal "false"

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)"
target "https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)"
literal "false"

\end_inset


\end_layout

\end_body
\end_document
