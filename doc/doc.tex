\documentclass[british]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage[unicode=true, colorlinks=true, citecolor=blue, linkcolor=blue,
urlcolor=blue]{hyperref}
\usepackage{standalone}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{amssymb}

\usepackage[style=authoryear-ibid,backend=biber]{biblatex}
\addbibresource{references.bib}

\usepackage{geometry}
\geometry{verbose,lmargin=3cm,rmargin=3cm}

\usepackage{xcolor}
\definecolor{magnolia}{rgb}{0.97, 0.96, 1.0}
\definecolor{dartmouthgreen}{rgb}{0.05, 0.5, 0.06}

\usepackage[newfloat]{minted}
\setminted{bgcolor=magnolia}

\usepackage{caption}
\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Source Code}

%for EBNF:
\usepackage{csquotes}

\newcommand\prv{bc}
\newcommand\m[1]{\mintinline{\prv}{#1}}
\newcommand\discuss[1]{\textcolor{dartmouthgreen}{#1}}
\newcommand\name{\texttt{\textsc{[prove]}}}
\newcommand\example[1]{
	\begin{code}
	\captionof{listing}{\texttt{examples/#1.prove}}\label{code:#1}
	\inputminted[linenos]{\prv}{examples/#1.prove}
	\end{code}

	\begin{figure}[!h]
	\caption{Representation of source~code~\ref{code:#1}}\label{fig:#1}
	\centering
	\subfloat[\centering Legend]{%
		\includegraphics[width=\textwidth, height=8cm,
		keepaspectratio]{tikz/legend.pdf}
	}
	\subfloat[\centering Graph of source~code~\ref{code:#1}]{%
		\includegraphics[width=\textwidth, height=8cm,
		keepaspectratio]{tikz/#1.pdf}
	}
	\end{figure}

	\begin{code}
	\captionof{listing}{\name\ output for \texttt{examples/#1.prove}}%
	\label{code:#1out}
	\inputminted[linenos]{\prv}{examples/out/#1.out}
	\end{code}
}

\providecommand{\tabularnewline}{\\}

\title{\name\ }

\makeatletter
\makeatother

\begin{document}

\maketitle

\section{Introduction}

This document is work in progress. All source code as well as the most recent
version of this document can be found on GitHub (see:
\href{https://github.com/g-regex/prove/blob/main/doc/doc.pdf}%
{\texttt{https://github.com/g-regex/prove/blob/main/doc/doc.pdf}}). The purpose
of this document to introduce notation, vocabulary and some underlying
principles in order to facilitate efficient communication about this project.
Furthermore this document could serve as an introduction to the project, if
anybody wants to join the project.

\pagebreak{}

\section{Terminology}

Let us start with some basic definitions

\begin{itemize}
	\item
		A \emph{statement} is a concatenation of one or more pair/s of square
		brackets enclosing another statement, a formula or an identifier.
	\item
		A \emph{formula} is a concatenation of statements and formulators.
		The empty string is a special case of a formula. Apart from this special
		case every formula must contain at least one statement and at least
		one formulator.
%	\item
%		A \emph{formulator }is a sequence of legal (see figure~\ref{fig:ebnf})
%		characters. A formulator does not contain any square brackets but
%		is delimited by a closing square bracket or the beginning of the file
%		at its beginning and an opening square bracket or the end of the file
%		at its end.
	\item
		A \emph{formulator} is a sequence of legal (see figure~\ref{fig:ebnf})
		characters delimited by either square brackets or the beginning or the
		end of the file.
	\item
		An \emph{identifier} is a formulator, which is delimited by an opening
		square bracket at its beginning and by a closing square bracket at its
		end.
%	\item
%		To refer to formulators or identifiers more generally, we will use
%		the term \emph{symbol }in this document.
	\item
		To refer to statements or formulas more generally, we will use the
		term \emph{expression }in this document.
	\item
		To refer to a formula, which is not an equality and not an implication,
		the term \emph{ordinary formula} will be used throughout the document.
	\item
		When we speak of a \emph{character} in this document, we mean a
		uppercase or lowercase Latin letter, a number or a special character
		(see figure~\ref{fig:ebnf}). Opening and closing square brackets, and
		the reserved formulators \m{=}, \m{=>} are not referred to as characters
		in this document.
%	\item
%		In the current implementation and negated statement is still a statement
%		and not a formula. The \m{!} is currently not a formulator -\ probably
%		this has to be discussed.
	\item
		The terms \emph{variable} and \emph{constant} can be used to refer
		to an identifier. Which term is to be used depends on the context,
		we are using it in (see Subsection~\ref{sec:var}).
	\item
		The term \emph{real constant} refers to a formula, comprised of exactly
		one formulator and exactly one empty statement.
\end{itemize}

\pagebreak{}

\section{Syntax}

The syntax of the \name\ language can conveniently be described by means of the
extended Backus-Naur form (EBNF), which is a meta syntax notation defined in the
ISO/IEC 14977 standard \parencite{ISO}. Using an EBNF enables us to recursively
and unambiguously describe nested patterns by grouping syntactic elements to so
called $\langle\texttt{production}\rangle$s.  It must always be possible to
`unpack' a production in a unique and finite way, resulting in a (sequence of)
\textit{terminal} strings, indicated by quotation marks. In order to correctly
interpret the \name\ EBNF it is sufficient to understand the meaning of the meta
characters shown in figure~\ref{fig:meta}.

\medskip{}

\begin{figure}[!ht]
\centering
\begin{doublespace}
\begin{tabular}{l|l}
$|$ & indicates `or'\tabularnewline\
$(\dots)$ & groups productions and/or terminals together; only useful in
combination with $|$\tabularnewline\
$[\dots]$ & indicates optionality\tabularnewline\
$\{\dots\}$ & indicates zero or more repetitions\tabularnewline\
\end{tabular}%\bigskip{}
\caption{Meta characters of the Extended Backus-Naur Form}\label{fig:meta}
\end{doublespace}
\end{figure}

\begin{figure}[!ht]
\centering
\input{ebnf}
\caption{Extended Backus-Naur Form of the \name\ language}\label{fig:ebnf}
\end{figure}

Using this notation the \name\ language can be described by the EBNF shown in
figure~\ref{fig:ebnf}.  Every EBNF needs to have an initial production as a
starting point.  It is convention that this distinguished production is to be
listed first, so in this case, $\langle\texttt{expression}\rangle$ is the
initial production. As one might notice a valid \name\ file might contain either
a statement or a formula. This design choice has been made in order to account
for axioms and theorems that might be given in the human readable form of
statements in the \name\ language.  Proofs on the other hand will be given in
the form of a formula, having only \m{=>} formulators at its outermost level. We
could easily think of other formulas, which will not satisfy this requirement
and thereby neither constitute an axiom/theorem nor a proof. A \name\ file
containing such a formula would be syntactically correct but would not have any
meaning.

\pagebreak{}

\section{Semantic}

When generating a couple of syntactically correct snippets of \name\ code, one
realises that not all code adhering to the rules of the EBNF makes sense -\ at
least not without introducing more conventions.

\medskip{}

Consider the following code:

\begin{minted}{\prv}
[a]and[b]=[c]=>[b][c]
\end{minted}

The use of \m{=} and \m{=>} is ambiguous in this context, since \m{=} could
refer to everything on its right hand side or just to \m{[c]}. Similarly \m{=>}
could refer to everything to its left hand side or just to \m{[c]}. This problem
could be addressed by introducing an order of precedence (e.g.\ non reserved
formulators, \m{=}, \m{=>}). However, the implications of this approach should
be carefully considered. Precedence can easily be encoded in the EBNF, without
changing the set of valid code patterns. By doing so we could elegantly encode a
part of the language's meaning in its syntactic structure. As tempting as this
idea might be, there is a negative side effect coming along with this approach.
Introducing precedence between formulators will set brackets \emph{implicitly}.
Since the visibility and meaning of identifiers (variables/constants) depends on
the depth of nesting of statements (i.e.\ on brackets), the approach of
precedence might lead to counter-intuitive code.\newline 

Instead the following semantic rule is introduced:
\begin{itemize}
\item \m{=}, \m{=>} and other formulators must not be mixed \checkmark\
\end{itemize}

\medskip{}

It might also be convenient to restrict the form an equality can have.
Especially with respect to a straight-forward implementation, it would
make sense to only let single statements (i.e.\ only one pair of square
brackets at the outermost level) to be equal to each other.\newline

Therefore the following rules are suggested:
\begin{itemize}
	\item
		Equalities are only such formulas, which are a concatenation of single
		statements and \m{=}, where no single statement is next to another
		single statement and no \m{=} is next to another \m{=} \checkmark\
	\item
		An equality must start and end with a single statement. \checkmark\
\end{itemize}
\medskip{}

Further, the following rule for implications is suggested:

\begin{itemize}
\item \m{=>} must not appear at the end of a $\langle\texttt{statement}\rangle$
\end{itemize}
\pagebreak{}

\section{Representation}

Let us have a look at the following statement:

\begin{code}
\captionof{listing}{Example}\label{code:ex1}
\inputminted[linenos]{\prv}{examples/exmp1.prove}
\end{code}

An intuitive approach for representing the structure of this code is by thinking
of it as a tree, where every statement and every formulator is represented by a
node. It is worth mentioning that this tree can be interpreted as a binary tree
(each node has one parent node and at most two children -\ one at the left and
one at the right). However it is more intuitive to not think of this binary tree
in its usual form, but to rotate it leftwards. Then every node can have (at most
two) children -\ either below or to the right -\ and a parent (exactly one -\
expect for the root) to the left or above it.

As we see, there are several ways of thinking of a node as a child or a parent
to another node (i.e.\ does a node lie in between another node and the root or
does it lie above another node in the graphical representation). For the rest of
the document, we will use the following terminology, always referring to the
proposed graphical representation of the tree:

\begin{itemize}
	\item
		A \emph{child} is a node, which lies below another node.
	\item
		A \emph{parent} is a node, which lies above another node.
	\item
		The nodes to the sides of another node are referred to as the
		\emph{left} and \emph{right} nodes respectively.
\end{itemize}

\subsection{Graph creation}\label{sec:creation}

When creating a tree for some corresponding \name\ code, we start with a single
node at the root of the tree. Since we refer to nodes in terms relative to
another node, we have to keep track of our current position in the tree, while
creating it. This position will be referred to as the \emph{current} node. In
the beginning the root is the current node.

Every node can have a number of properties, some of which exclude others. For
example, every node can have a child or carry a formulator, but not both.
Processing the code bracket by bracket and formulator by formulator, we now
perform the following steps:

\begin{itemize}
	\item 
		When encountering a \m{[}, we check, whether the current node has a
		child or carries a formulator. If not, we create a child to the current
		node. This child becomes the current node. Otherwise we create a
		node to the right and a child to that node. That node then becomes
		the current node.
	\item
		When encountering a formulator, the formulator property of the current
		node is set.
	\item
		When encountering a \m{]}, we move from one node to another leftwards
		until we encouter the leftmost node, which has a parent. Then we move to
		that parent, which becomes the current node.
\end{itemize}

On the next page a graphical representation of
source~code~\ref{code:ex1} can be found.
\pagebreak{}

\begin{figure}[!ht]
\caption{Representation of source~code~\ref{code:ex1}}\label{fig:ex1}
\centering
\subfloat[\centering Legend]{%
	\includegraphics[width=\textwidth, height=10cm,
	keepaspectratio]{tikz/legend.pdf}
}
\subfloat[\centering Graph of source~code~\ref{code:ex1}]{%
	\includegraphics[width=\textwidth, height=10cm,
	keepaspectratio]{tikz/exmp1.pdf}
}
\end{figure}

The tree shown in figure~\ref{fig:ex1} (b) was automatically generated by \name\
following the steps described above. The nodes have been numbered in the order
they have been created, which corresponds to a pre-order traversal numbering of
the tree. The flags drawn on the righthand side of each node encode information,
which has been gathered during the creation of the graph.  E.g.\ the
\texttt{NEWC} flag indicates that the statement contained by a node introduces a
new constant (see Subsection~\ref{sec:var}). These flags correspond to single
bits in the structure corresponding to each node in memory. Using these flags
simplifies later tasks by storing already gained information and thereby
avoiding repeated computation of frequently performed steps.\newline

Remark: Some of these flags are set for nodes, which they are not applicable to
and some flags are not set, where they could be.
This has technical reasons (mainly related to computational efficiency) and is
nothing we have to worry about.

\pagebreak{}

\subsection{The flags \texttt{IMPL}, \texttt{EQTY} and \texttt{FMLA}}
During graph creation the flags \texttt{IMPL},
\texttt{EQTY} and \texttt{FMLA} are set respectively according to the following
rules:

\begin{itemize}
	\item
		When the current node contains an \m{=>} formulator, the \texttt{IMPL}
		flag is set.
	\item
		When the current node contains an \m{=} formulator, the \texttt{EQTY}
		flag is set.
	\item
		When the current node contains any other formulator, the \texttt{FMLA}
		flag is set.
	\item
		When a new node to the right of the current node is created, the
		respective state of the flags \texttt{IMPL}, \texttt{EQTY} and
		\texttt{FMLA} of the current node are copied over to the new node.
	\item
		When encountering a \m{]} and moving to the left-most node of the
		current sub-tree (see Subsection~\ref{sec:creation}), the states of the
		flags \texttt{IMPL}, \texttt{EQTY} and \texttt{FMLA} are copied over
		from right to left.
\end{itemize}

\subsection{The flags \texttt{JUST} and \texttt{LOCK}}

One of the flags used is the \texttt{JUST} flag (short for \emph{justified}). It
only has a meaning in combination with the \texttt{IMPL} flag. 
\medskip
The \texttt{JUST} flag is set according the following rules:

\begin{itemize}
	\item
		When a new child node is created and the \texttt{JUST} flag or the
		\texttt{LOCK} flag of the current node is set, the \texttt{JUST} flag
		\emph{and} the \texttt{LOCK} flag of the new child node are set as well. 
	\item
		When a new child node is created and for the current node none of the
		flags \texttt{IMPL}, \texttt{EQTY} or \texttt{FMLA} are set, the flags
		\texttt{JUST} and \texttt{LOCK} are set for the new child node.
	\item
		When a new node to the right of the current node is created and any of
		the flags \texttt{EQTY}, \texttt{FMLA} or \texttt{LOCK} of the current
		node are set, the \texttt{JUST} flag of the new node to the right is
		set. The state of the \texttt{LOCK} flag is carried over to the new
		node.
	\item
		When a new node to the right of the current node is created and the
		\texttt{IMPL} flag of the current node is \emph{not} set, the
		\texttt{JUST} flag of the \emph{current} node is set.
\end{itemize}

The only function of the \texttt{LOCK} flag is to ensure that all nodes in a
sub-tree below a node with a \texttt{JUST} flag set has also the \texttt{JUST}
flag set.\newline

The \texttt{JUST} flag can be interpreted as follows: If the
\texttt{JUST} flag is set, the appearance of the corresponding node in the tree
is justified in the sense that we accept its appearance in the currently
processed subtree without verifying it (see Section~\ref{sec:verify}). We do not
speak of \emph{justification}, since a missing \texttt{JUST} flag does not imply
that there is no good reason for the corresponding node to appear at that
position in the tree. However, the meaning of the combination of the
\texttt{IMPL} flag and the \texttt{JUST} flag will be elaborated in the
beginning of Section~\ref{sec:verify}.

%\begin{itemize}
%	\item
%		If an expression is an implication (i.e., all formulators are \m{=>}),
%		then every statement occurring after the first formulator is not
%		justified.
%	\item
%		Every expression in an equality (i.e., all formulators are \m{=}) is
%		already justified. (Remark: An equality has all the properties a
%		two-sided implication would have, but in addition to that it also allows
%		for substituting one statement with another)
%	\item
%		If an expression is justified, all statements contained within it are
%		justified as well.
%	\item
%		If and only if an expression is not justified and part of an
%		implication, it requires verification (see Section~\ref{sec:verif}).
%\end{itemize}
%Justified statements, which are part of an implication, will be called
%\emph{assumptions}.
%\medskip{}

\pagebreak{}

\section{Verification}\label{sec:verify}

\textcolor{dartmouthgreen}{Verifying a node means finding another node at an
eligible position in the tree (see Subsection~\ref{sec:reach}), which is similar
to the current node (see Subsection~\ref{sec:similar})}.  Whether a node has to
be verified depends on the combination of the state of its corresponding
\texttt{IMPL} flag and \texttt{JUST} flag. The following rules apply:

\begin{itemize}
	\item
		If both, the \texttt{IMPL} flag and the \texttt{JUST} flag, are set, the
		corresponding node contains an assumption -\ a statement not depending
		on any other statements. Such a node does not require verification.
	\item
		If neither the \texttt{IMPL} flag nor the \texttt{JUST} flag are set,
		the corresponding node does not require verification.
	\item
		If the \texttt{IMPL} flag is set and the \texttt{JUST} flag is unset,
		the corresponding node requires verification.
\end{itemize}

\subsection{Output}

%To illustrate these ideas, let us now look at the following implication:
The \name\ software currently only produces debugging output. However, this
output might help understanding the basic principles of the software and could
be developed further to some meaningful and user-friendly output.\newline

The debugging output is a modified version the original \name\ code, in which
line breaks, tabstops and verification information has been inserted. On the
next page you will find a short explanation of the debugging information and an
example.

\pagebreak{}

\begin{code}
\captionof{listing}{Example}\label{code:impl1}
\inputminted[linenos]{\prv}{examples/impl1.prove}
\end{code}

\begin{figure}[!h]
\caption{Representation of source~code~\ref{code:impl1}}\label{fig:impl1}
\centering
\includegraphics[width=\textwidth, height=7cm, keepaspectratio]{tikz/impl1.pdf}
\end{figure}

\begin{code}
\captionof{listing}{\name\ output for
Source~Code~\ref{code:impl1}}\label{code:impl1out}
\inputminted[linenos]{\prv}{examples/out/impl1.out}
\end{code}

Source~Code~\ref{code:impl1} shows a trivial example \name\ code, which requires
a verification step after processing the last statement. As
figure~\ref{fig:impl1} shows, node~7 has the \texttt{IMPL}~flag set and the
\texttt{JUST}~flag unset. Thus node~7 requires verification.\newline

Source~Code~\ref{code:impl1out} shows the verification information, which has to
be interpreted as follows:

\textcolor{dartmouthgreen}{\begin{itemize}
	\item
		If a node requires verification, the number of the node is printed in
		braces (e.g.\ \m{{7}}) after the corresponding statement.
	%\item
	%	The number of every node, the node to be verified is compared to, is
	%	printed in angular brackets (e.g.\ \m{<4>}).
	%\item
	%	If the sub-trees \emph{below} the two compared nodes are similar to each
	%	other, a hash is printed within the angular brackets (e.g.\ \m{<0#>}).
	\item
		If a node was verified successfully, the number of the node it is
		similar to, preceded by a hash, is printed in angular brackets (e.g.\
		\m{<#0>}).
\end{itemize}}

%Remark on figure~\ref{fig:impl1}: Nodes 0, 2 and 4 are part of an implication
%but do not have the \texttt{IMPL} flag set. This has technical reasons: The
%flags indicating the type of formula (i.e. \texttt{IMPL}, \texttt{EQTY} and
%\texttt{FMLA}) are set after encountering the first formulator. When stepping
%through the nodes leftwards to finally get to the parent level, these flags are
%copied over. Since this does not happen at the topmost level, these flags are
%not set. As we are not interested in these flags at those positions, we do not
%have to worry about that.

%In source~code~\ref{code:impl1} we make three assumptions: We state that there
%are three identifiers \m{a}, \m{b} and \m{c}. Note the flags in the graph
%telling us that the appearance of the nodes 0, 2 and 4 at their respective
%positions is justified.  After the \m{=>} formulator, we have another
%expression stating that there is an \m{a}.  This node is not justified and part
%of an implication, so it requires verification. In order to verify statement~7,
%we check the similarity of the sub-tree with node~8 (node~7's child) as its
%root against the sub-trees with the nodes 1, 3 and 5 as their roots
%respectively.

\pagebreak{}

\subsection{Similarity of sub-trees}\label{sec:similar}
\textcolor{dartmouthgreen}{Two sub-trees can only be compared to each other,
after all variables (with respect to the parent of the root of the
respective sub-tree) have been substituted (see Subsection~\ref{sec:var}).} The
compared sub-trees are found to be similar, when the following conditions hold:

\begin{itemize}
	\item 
		Each node from the one sub-tree has a corresponding node in the other
		subtree.
	\item
		If one of the nodes has a node to its right, the corresponding node does
		so as well.
	\item
		If one of the nodes has a child, the corresponding node does so as well.
	\item
		If one of the nodes carries a formulator, the other node must carry the
		same formulator.
\end{itemize}

In the example of source~code~\ref{code:impl1} the compared sub-trees consist of
only a single node, each carrying a formulator. The similarity of the sub-trees
under nodes 0 and 7 (with the nodes 1 and 8 as their roots respectively) is
trivial. If we want to verify slightly more involved formulas, we have to
discuss some more concepts. We will do so in the following subsections.

\subsection{Variables and constants}\label{sec:var}

As mentioned above, identifiers (i.e.\ formulas, which consist of a single
formulator) can be variables or constants depending on the context. The context
is given by the tree and the position of a specific node, from whose
perspective we will determine the status of an identifier.

\medskip{}
\textcolor{dartmouthgreen}{An identifier can have two different states with
respect to a specific node: \emph{unknown} and \emph{constant}.}

\subsubsection{The flags \texttt{NEWC} and \texttt{VAR}}
\textcolor{dartmouthgreen}{The state of an identifier can be determined by
looking at the flags \texttt{NEWC} and \texttt{VAR}:}

\textcolor{dartmouthgreen}{\begin{itemize}
	\item 
		If the \texttt{NEWC} flag of a node is set, then the identifier is a
		constant for all nodes to the right of that node and their respective
		sub-trees.
	\item
		If the \texttt{VAR} flag of a node is set, then the subtree below that
		node contains at least one node with the \texttt{NEWC} flag set. The
		identifiers in these nodes are subject to substitution and unknown to
		the nodes (and their respective sub-trees) to the right of the node with
		the set \texttt{VAR} flag. Of course this unknown status will be
		overwritten as soon as an identifier will be declared.
\end{itemize}}

\pagebreak{}

\subsubsection{Examples}
To illustrate the concept of variables and constants, let us slightly modify
source~code~\ref{code:impl1} and put square brackets around the first two
statements:

\example{var1}

\discuss{%
	Notice that statement~8 cannot be verified. It now has the
	\texttt{NEWC} flag set, indicating that a new constant has been introduced.
	The existence of such a constant can not be verified without adding one
	additional assumption: \m{[c=a]}.
}\newline

%Node~0 on now carries the \texttt{VAR} flag telling us that its sub-tree
%contains at least one variable.  This is, because the constants, declared in
%statement 0, are only constants within that sub-tree: As can be seen in
%figure~\ref{fig:var1} (b), the nodes 1 and 3 -\ just as the nodes 0 and 2 in
%source~code~\ref{code:impl1} -\ still carry the \texttt{NEWC} flag.  For all
%nodes to the right of node 0 the identifiers \m{a} and \m{b} are treated as
%variables. They cannot be used directly, but have to be replaced by another
%sub-tree (i.e.\ statement) or (single!) formulator.

\pagebreak{}
\example{var2v1}
\discuss{%
	Here \m{[[a]=[c]]} is part of the initial assumptions. The verification is
	successful as node~14 (\m{[a]}) is found to be similar to node~5. To realise
	this behaviour, we have to break with the previously introduced priciples of
	constants and variables, since the identifier \m{a}, will be a constant for
	every node to the left of node~7. This might become a problem in later
	proofs.
}

\pagebreak{}
%\example{var2v2}
%\discuss{%
%	Here node~16 can be verified by node~10. At first it looks like the
%	verification was successful because of the used equality, but in fact
%	node~10 is only taken into account because of the earlier appearance of
%	node~7. In fact node~9 could be left out completely without changing the
%	result.
%}\newline
%
%\discuss{%
%	Note: The multiple comparisons with node~0 in the end correspond to various
%	possible substitutions of the variables represented by the nodes 1 and 3
%	respectively. In future, this will be subject to optimisation.
%}

\pagebreak{}
\example{var3v1}
\discuss{%
	This is a variation of Source~Code~\ref{code:var2v1}, where \m{[c=a]} is an
	assumption in an implication at a deeper level.
}

%\pagebreak{}
%\example{var3v2}
%\discuss{%
%	Similar problems as in Source~Code~\ref{code:var2v2} arise here.
%}

\pagebreak{}
\example{var4v1}
\discuss{%
	Here, nodes 8 and 10 cannot be verified, since there are no nodes in
	eligible positions which they are similar to.
}

\pagebreak{}
\example{var4v2}
\discuss{%
	Here, same problems as in Source~Code~\ref{code:var4v1} arise.
}

\pagebreak{}

\subsection{Reachability}\label{sec:reach}


As mentioned before verification of a node involves comparing the current node
against a number of sub-trees.\\ To select the sub-trees the current node is
compared against, we have to introduce the concept of \emph{reachability}.


\begin{code}
\captionof{listing}{Example}\label{code:reach1}
\inputminted[linenos]{\prv}{examples/reach1.prove}
\end{code}

\begin{figure}[!h]
\caption{Representation of source~code~\ref{code:reach1}}\label{fig:reach1}
\centering
\subfloat[\centering Legend]{%
	\includegraphics[width=\textwidth, height=10cm,
	keepaspectratio]{tikz/legend.pdf}
}
\subfloat[\centering Graph of source~code~\ref{code:reach1}]{%
	\includegraphics[width=\textwidth, height=10cm,
	keepaspectratio]{tikz/reach1.pdf}
}
\end{figure}

To determine which nodes are reachable from the current node, we go back in the
tree node by node moving to the left and upwards. All of these nodes containing
statements are reachable from the current node. Further, the following holds:

\begin{itemize}
	\item
		If a reachable statement contains variables, all variables have to be
		substituted by reachable nodes containing no variables.
	\item
		If a reachable statement contains another statement, that statement is
		also reachable.
	\item
		If a reachable statement contains an implication, the conclusions of the
		implication are reachable, when the assumptions can be verified. 
	\item
		If a reachable statement contains an equality, all statements in that
		equality are reachable, if at least one statement can be verified.
\end{itemize}

The verification of assumptions might depend on the substitution of variables.
\newline

Let us consider source~code~\ref{code:reach1}. Translated to English it says:
There is an identifier \m{a} and there is a property \m{[b]prop}, which can be
applied to any variable \m{b}. It follows that \m{a} has this property.
\newline

Now let us understand, how the \name\ code can be verified using the tree from
figure~\ref{fig:reach1}: Nodes 0 and 2 and their respective sub-trees are
assumptions and do not have to be verified. Node 7 is part of an implication
and not already justified -\ in fact it is the only node in the tree, which
satisfies these conditions -\ so it has to be verified. The nodes 0 and 2 are
the only nodes, which are reachable from node~7. Node~0 is a constant statement
(i.e.\ a statement not containing any variables), whereas node~2 is a variable
statement. Before attempting to compare node~7 with node~2 the variable has to
be substituted. The variable node in the sub-tree below statement~2 is node
number~4 (\m{b}), which is to be replaced by the children of all constant
statements (one at a time of course), which are reachable from node~7. In this
case the only constant statement, which is reachable from node~7 is statement~0
(\m{[a]}), so we substitute node~4 (\m{b}) by the child of node~0, namely node~1
(\m{a}), before we compare the sub-tree under node~2 (now \m{[a]prop}) against
the sub-tree under node~7 (\m{[a]prop}).
\newline

To get deeper insight in how the reachability in sub-trees is determined, let us
look at a slightly more involved example. In source~code~\ref{code:reach2} we
make three assumptions: There is an identifier \m{a}, there is a property
\m{[b]prop}, which can by applied to any identifier, and if \m{a} has this
property, then it also has a second property. In this example the statements 17
and 22 require verification. Statement~17 can -\ like in the previous example -\
be justified by statement~2. For statement~22 however, we have to explore the
sub-tree below node~6. Node~6 contains an implication, which depends on the
assumption of statement~7, so before we can determine, whether any of the
statements in implication~6 are reachable, we have to verify assumption~7.
Assumption~7 therefore has to be compared against all constant nodes, which are
directly reachable from node~22, namely nodes 17 and 0. It turns out that
assumption~7 can be verified using statement~17, which lets us reach
statement~12 from node~22, which we intend to verify. Since the statements
(\m{[a]prop2}) in node~22 and node~12 are similar, the verification is
successful.

Note that without statement~17, statement~22 could not be verified, since
assumption~7 is compared against all \emph{constant} statements, which are
directly reachable from node~22.
\pagebreak{}

\begin{code}
\captionof{listing}{Example}\label{code:reach2}
\inputminted[linenos]{\prv}{examples/reach2.prove}
\end{code}

\begin{figure}[!h]
\caption{Representation of source~code~\ref{code:reach2}}\label{fig:reach2}
\centering
\includegraphics[width=\textwidth, height=15cm,
keepaspectratio]{tikz/reach2.pdf}
\end{figure}

\pagebreak{}

\begingroup
\setstretch{0.8}
\setlength\bibitemsep{10pt}
\printbibliography\
\endgroup

\end{document}
