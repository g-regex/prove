\documentclass[british]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\geometry{verbose,lmargin=3cm,rmargin=3cm}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage[unicode=true, colorlinks=true, citecolor=blue, linkcolor=blue, urlcolor=blue]{hyperref}

\makeatletter

\providecommand{\tabularnewline}{\\}

\usepackage{graphicx}
\usepackage{subfig}

\usepackage[newfloat]{minted}
\usepackage{xcolor}
%\usepackage{natbib}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows.meta}
\usepackage{caption}

\definecolor{magnolia}{rgb}{0.97, 0.96, 1.0}
\setminted{%
  bgcolor=magnolia,%
}

\newcommand\prv{bc}
\newcommand\m[1]{\mintinline{\prv}{#1}}
\newcommand\cm[1]{\mintinline{c}{#1}}
\newcommand\name{\texttt{\textsc{[prove]}}}

\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Source-Code}

\newcommand\scref[1]{Source-Code~\ref{code:#1}}
\newcommand\figref[1]{Figure~\ref{fig:#1}}

%\usepackage{subfiles}
\usepackage{standalone}

\usepackage{csquotes}
\usepackage[style=authoryear-ibid,backend=biber]{biblatex}
\addbibresource{references.bib}

\title{\name\ }

\makeatother

\begin{document}

\maketitle

\section{Introduction}

This document is work in progress. All source code as well as the most recent version of this document can be found on GitHub (see: \href{https://github.com/g-regex/prove/blob/main/doc/doc.pdf}{\texttt{https://github.com/g-regex/prove/blob/main/doc/doc.pdf}}). The purpose of this document to introduce
notation, vocabulary and some underlying principles in order to facilitate
efficient communication about this project. Furthermore this document
could serve as an introduction to the project, if anybody wants to
join.

\pagebreak{}

\section{Terminology}

Let us start with some basic definitions
\begin{itemize}
\item A \emph{statement} is a concatenation of one or more pair/s of square
brackets enclosing another statement, a formula or an identifier.
\item A \emph{formula} is a concatenation of statements and formulators.
The empty string is a special case of a formula. Apart from this special
case every formula must contain at least one statement and at least
one formulator.
\item A \emph{formulator }is a sequence of legal (see later definition)
characters. A formulator does not contain any square brackets but
is delimited by a closing square bracket or the beginning of the file
at its beginning and an opening square bracket or the end of the file
at its end.
\item An \emph{identifier} is a sequence of legal characters and is delimited
by an opening square bracket at its beginning and by a closing square
bracket at its end.
\item To refer to formulators or identifiers more generally, we will use
the term \emph{symbol }in this document.
\item To refer to statements or formulas more generally, we will use the
term \emph{expression }in this document.
\item To refer to a formula, which is not an equality and not an implication, the term \emph{ordinary formula} will be used throughout the document.
\item When we speak of a \emph{character} in this document, we mean a uppercase
or lowercase Latin letter, a number or a special character from a
list that may be extended. Opening and closing square brackets, the
literals used in the reserved formulators \m{=}, \m{=>} and the
negation \m{!} are not referred to as characters in this document.
\item In the current implementation and negated statement is still a statement
and not a formula. The \m{!} is currently not a formulator -\ probably
this has to be discussed.
\item The terms \emph{variable} and \emph{constant} can be used to refer
to an identifier. Which term is to be used depends on the context,
we are using it in (see later definition).
\item The term \emph{real constant} refers to a formula, comprised of exactly
one formulator and exactly one empty statement.
\end{itemize}
\pagebreak{}

\section{Syntax}

\subsection{EBNF}

The syntax of the \name\ language can conveniently
be described by means of the extended Backus-Naur form \parencite{Extended}, which is a meta syntax notation defined in the ISO/IEC 14977
\parencite{ISO} standard. Using an EBNF enables us
to recursively and unambiguously describe nested patterns by grouping
syntactic elements to so called $\langle\texttt{production}\rangle$s.
It must always be possible to `unpack' a production in a unique
and finite way, resulting in a (sequence of) \textit{terminal} symbols,
indicated by quotation marks. In order to correctly interpret the
\name\ EBNF it is sufficient to understand
the meaning of the following meta characters:

\bigskip{}

\begin{doublespace}
\begin{tabular}{l|l}
$|$ & indicates `or'\tabularnewline\
$(\dots)$ & groups productions and/or terminals together; only useful in combination
with $|$\tabularnewline\
$[\dots]$ & indicates optionality\tabularnewline\
$\{\dots\}$ & indicates zero or more repetitions\tabularnewline\
\end{tabular}\bigskip{}

\end{doublespace}

Using this notation the \name\ language can be described by the following EBNF:

\input{ebnf}

\medskip{}

Every EBNF needs to have an initial production as a starting point.
It is convention that this distinguished production is to be listed
first, so in this case, $\langle\texttt{expr}\rangle$ is the initial
production. As one might notice a valid \name\ file
might contain either a statement or a formula. This design choice
has been made in order to account for axioms and theorems that might
be given in the human readable form of the \name\ language.
Proofs on the other hand will be given in the form of a formula, having
only \m{=>} formulators at its outermost level. We could easily think
of other formulas, which will not satisfy this requirement and thereby
neither constitute an axiom/theorem nor a proof. A \name\
file containing such a formula would be syntactically correct but
would violate semantic rules, which will be established later. \pagebreak{}

\subsubsection{Examples}

Here are some examples of productions and some motivations for the
design of the syntax. We will work our way up from bottom to top through
the EBNF.
\begin{itemize}
\item A $\langle\texttt{character}\rangle$ can be any letter, number or
one of the 10 special characters as indicated in the EBNF\@. Examples
of valid $\langle\texttt{character}\rangle$s are \m{a}, \m{T},
\m{7}, \m{&}.
\item A $\langle\texttt{symbol}\rangle$ is a sequence of one or more characters.
Examples of valid $\langle\texttt{symbols}\rangle$s are: \m{a7we},
\m{T}, \m{76}, \m{&q}. Note that \m{T} is a $\langle\texttt{symbol}\rangle$
and a $\langle\texttt{character}\rangle$ at the same time. This does
not mean that the grammar is ambiguous. A single \m{T} will always
be interpreted in this way, but it depends on the context, whether
we are interested in the fact of \m{T} being a $\langle\texttt{symbol}\rangle$
or \m{T} being a $\langle\texttt{character}\rangle$.
\item A $\langle\texttt{formulator}\rangle$ is either a $\langle\texttt{symbol}\rangle$
or any one of the terminals (fixed, not \textquotedbl\ unpack-able\textquotedbl{}
elements of an EBNF) \m{=} or \m{=>}. Examples of valid $\langle\texttt{formulator}\rangle$s
are \m{a7we}, \m{T}, \m{=}, \m{=>}. Note that \m{=T} is not a
valid $\langle\texttt{formulator}\rangle$. Seeing that \m{T} can
be a $\langle\texttt{formulator}\rangle$ (comprised of a $\langle\texttt{symbol}\rangle$)
in one case and just a $\langle\texttt{symbol}\rangle$ (not packed
inside a $\langle\texttt{formulator}\rangle$) in another case, one
might worry about ambiguity. However, having a close look at the EBNF,
we see that $\langle\texttt{formulator}\rangle$s only occur in between
$\langle\texttt{statement}\rangle$s and $\langle\texttt{string}\rangle$s
only within $\langle\texttt{statement}\rangle$s. The user of the
language has great freedom in naming formulators and identifiers (TODO:
define formulators and identifiers in this document, i.e.\ not the
productions, but what they represent), so it is up to the user to
choose them wisely. It could for example be confusing to name a formulator
\m{7}, but \m{add7} makes intuitively sense.
\item A $\langle\texttt{statement}\rangle$ is a concatenation of one or
more pairs of square brackets each containing either a $\langle\texttt{formula}\rangle$,
a $\langle\texttt{symbol}\rangle$ or a $\langle\texttt{statement}\rangle$.
Examples of valid $\langle\texttt{statement}\rangle$s are \m{[]},
\m{[a][b][[a]in[b]]}, \m{[[]]}, \m{[[a]or[b]]}.
\item A $\langle\texttt{formula}\rangle$ is comprised of at least one $\langle\texttt{statement}\rangle$
and at least one $\langle\texttt{formulator}\rangle$. The order of
occurrence does not matter. Examples of valid $\langle\texttt{formula}\rangle$e
are \m{[a]in[b]}, \m{[a]=[b][c]}, \m{[[a]a7we[b]]=>[c]}.
\end{itemize}

\section{Semantic}

When generating a couple of syntactically correct snippets of \name\
code, one realises that not all code adhering to the rules of the
EBNF makes sense -\ at least not without introducing more conventions.

\medskip{}

Consider the following code:

\begin{minted}{\prv}
[a]and[b]=[c]=>[b][c]
\end{minted}

The use of \m{=} and \m{=>} is ambiguous in this context, since
\m{=} could refer to everything on its right hand side or just to
\m{[c]}. Similarly \m{=>} could refer to everything to its left
hand side or just to \m{[c]}. This problem could be addressed by
introducing an order of precedence (e.g.\ non reserved formulators,
\m{=}, \m{=>}). However, the implications of this approach should
be carefully considered. Precedence can easily be encoded in the EBNF,
without changing the set of valid code patterns. By doing so we could
elegantly encode a part of the language's meaning in its syntactic
structure. As tempting as this idea might be, I can see a negative
side effect coming along with this approach. Introducing precedence
between formulators will set brackets \textit{implicitly. }Since the
visibility and meaning of identifiers (variables/constants) depends
on the depth of nesting of statements (i.e.\ on brackets), the approach
of precedence might lead to counter-intuitive code. Therefore I recommend
against the precedence approach.

Instead I suggest the following semantic rule, which will address
this issue:
\begin{itemize}
\item \m{=}, \m{=>} and other formulators must not be mixed
\end{itemize}
\medskip{}

Consider the following code:

\begin{minted}{\prv}
[a][b]=>[c]
\end{minted}

Translated to English this means `Let a and b be identifiers, then
we have an identifier c'. We do not know, where c comes from, since
it was not introduced before. Therefore I suggest the following rule:
\begin{itemize}
\item New identifiers must only be introduced in a part of a formula, which
is reserved for assumptions.
\end{itemize}
\medskip{}

To determine, which statements within a formula are assumptions and
which statements are conclusions, I'd like to put the following three
rules up for discussion:
\begin{itemize}
\item If the formula is an implication (i.e., all formulators are \m{=>}),
then every statement occurring before the first formulator is an assumption.
\item Every statement in an equality (i.e., all formulators are \m{=})
is an assumption, from which all other statements can be concluded.
(Remark: An equality has all the properties a two-sided implication
would have, but in addition to that in also allows substituting one
statement with another)
\item If a statement is an assumption, all statements contained in it are
assumptions as well.
\end{itemize}
\medskip{}

It might also be convenient to restrict the form an equality can have.
Especially with respect to a straight forward implementation, it would
make sense to only let single statements (i.e.\ only one pair of square
brackets at the outermost level) to be equal to each other. Therefore
I suggest the following rules:
\begin{itemize}
\item Equalities are only such formulas, which are a concatenation of single
statements and \m{=}, where no single statement is next to another
single statement and no \m{=} is next to another \m{=}
\item An equality must start and end with a single statement.
\end{itemize}
\medskip{}
Further I suggest the following rule for implications for obvious
reasons:
\begin{itemize}
\item \m{=>} must not appear at the end of a $\langle\texttt{statement}\rangle$
\end{itemize}
\pagebreak{}

\section{Representation}

Let us have a look at the following statement:

\begin{code}
\captionof{listing}{Example}\label{code:ex1}
\inputminted[linenos]{\prv}{examples/exmp1.prove}
\end{code}

An intuitive approach for representing the structure of this code
is by thinking of it as a tree, where every statement and every symbol is represented by a node. It is worth mentioning that this tree can be interpreted as a binary tree (each node has one parent node and at most two children -\ one at the left and one at the right). However it is more intuitive to not think of this binary tree in its usual form, but to rotate it leftwards. Then every node can have (at most two) children either below or to the right and a parent (exactly one -\ expect for the root) to the left or above it.

As we see, there are several ways of thinking of a node as a child or a parent to another node (i.e., does a node lie in between another node and the root or does it lie above another node in the graphical representation). For the rest of the document, we will use the following terminology, always referring to the proposed graphical representation of the tree:

\begin{itemize}
	\item
		A \emph{child} is a node, which lies below another node.
	\item
		A \emph{parent} is a node, which lies above another node.
	\item
		The nodes to the sides of another node are referred to as the \emph{left} and \emph{right} nodes respectively.
\end{itemize}

When creating a tree for some corresponding \name\ code, we start with a single node at the root of the tree. Since we refer to other nodes in terms relative to another node, we have to keep track of our current position in the tree, while creating it. This position will be referred to as the \emph{current} node. In the beginning the root is the current node.

Every node can have a number of properties, some of which exclude others. For example, every node can have a child or carry a symbol, but not both. Processing the code bracket by bracket and symbol by symbol, we now perform the following steps:

\begin{itemize}
	\item When encountering a \m{[}, we check, whether the current node carries a symbol. If not, we create a child to the current node. This child becomes the current node. Otherwise we create a node to the right and a child to that node. That node then becomes the current node.
	\item When encountering a symbol, the symbol property of the current node is set.
	\item When encountering a \m{]}, we move from one node to another leftwards until we encouter the leftmost node, which has a parent. Then we move to that parent, which becomes the current node.
\end{itemize}

On the next page you find the graphical representation of \scref{ex1}.
\pagebreak{}

\begin{figure}[!ht]
\caption{Representation of \scref{ex1}}\label{fig:ex1}
\centering
\subfloat[\centering Legend]{
	\includegraphics[width=\textwidth, height=10cm, keepaspectratio]{tikz/legend.pdf}
}
\subfloat[\centering Graph of \scref{ex1}]{
	\includegraphics[width=\textwidth, height=10cm, keepaspectratio]{tikz/exmp1.pdf}
}
\end{figure}

The tree shown in \figref{ex1} (b) was automatically generated by \name\ following the steps described above. The nodes have been number in the order they have been created, which corresponds to a pre-order traversal numbering of the tree \parencite{Tree}. The flags drawn on the righthand side of each node encode information, which has been gathered during the creation of the graph. E.g.\ the \texttt{ASMP} flag indicates that the statement contained by a node is an assumption. These flags are set and unset in a variable, which is part of the structure of the node in memory. This setup simplifies the verification process by storing already gained information and thereby avoiding repeated computation of frequently used steps.

Some of these flags are set for nodes, which they are not applicable to. This has technical reasons (mainly related to computational efficiency) and is nothing we have to worry about.

\pagebreak{}

\section{Verification}

Verifying a proof means, checking that every conclusion can be justified.
With respect to \name\ code, we imposed certain conditions on statements to be an assumption. For a statement to be a conclusion, two conditions have to be satisfied:

\begin{itemize}
	\item The statement must not be an assumption.
	\item The statement must be part of a formula, which contains (only!) \m{=>} formulators. 
\end{itemize}

To illustrate these ideas, let us now look at the following implication:

\begin{code}
\captionof{listing}{Example}\label{code:impl1}
\inputminted[linenos]{\prv}{examples/impl1.prove}
\end{code}

\begin{figure}[!h]
\caption{Representation of \scref{impl1}}\label{fig:impl1}
\centering
\includegraphics[width=\textwidth, height=10cm, keepaspectratio]{tikz/impl1.pdf}
\end{figure}

In \scref{impl1} we make three assumptions: We state thate there are three identifiers \m{a}, \m{b} and \m{c}. Note the flags in the graph telling us that the statements 0, 2 and 4 are assumptions. The identifiers themselves are not assumptions, so these flags are not applicable there. After the \m{=>} formulator, we have another statement stating that there is an \m{a}. This is not an assumption anymore and requires verification. In order to verify statement 7, we compare the sub-tree with node 8 (node 7's child) as its root against the sub-trees with the nodes 1, 3 and 5 as their roots respectively. Two sub-trees are found to be similar, when the following two conditions hold:

\begin{itemize}
	\item 
		Each node from the one sub-tree has a corresponding node in the other subtree.
	\item
		If one of the nodes has a node to its right, the corresponding node does so as well.
	\item
		If one of the nodes has a child, the corresponding node does so as well.
	\item
		If one of the nodes carries a symbol, the other node must carry the same symbol.
\end{itemize}

In the example of \scref{impl1} the compared sub-trees consist of only a single node, each carrying a symbol. The similarity of the sub-trees under nodes 0 and 7 (with the nodes 1 and 8 as their roots respectively) is trivial. Note the \texttt{TRUE} flag at node 7 indicating that the node has successfully been verified. If we want to verify slightly more involved formulas, we have to discuss some more concepts, namely the following:

\begin{itemize}
	\item 
		Variables and constants
	\item 
		Reachability
	\item 
		Negation
\end{itemize}

\pagebreak{}

\subsection{Variables and constants}

To illustrate the concept of variables and constants, let us slightly modify \scref{impl1} and put square brackets around the first two statements:

\begin{code}
\captionof{listing}{Example}\label{code:var1}
\inputminted[linenos]{\prv}{examples/var1.prove}
\end{code}

\begin{figure}[!h]
\caption{Representation of \scref{var1}}\label{fig:var1}
\centering
\subfloat[\centering Legend]{
	\includegraphics[width=\textwidth, height=10cm, keepaspectratio]{tikz/legend.pdf}
}
\subfloat[\centering Graph of \scref{ex1}]{
	\includegraphics[width=\textwidth, height=10cm, keepaspectratio]{tikz/var1.pdf}
}
\end{figure}

Notice now that statement 8 cannot be verified now. Instead of the \texttt{TRUE} flag it now carries the \texttt{NEWC} flag indicating that a new constant has been introduced. Node 0 on the other hand now carries the \texttt{VAR} flag telling us that its sub-tree contains at least one variable.
This is, because the constants, declared in statement 0, are only constants within that sub-tree: 
As can be seen in \figref{var1} (b), the nodes 1 and 3 -\ just as the nodes 0 and 2 in \scref{impl1} -\ still carry the \texttt{NEWC} flag.
For all nodes to the right of node 0 the identifiers \m{a} and \m{b} are treated as variables. They cannot be used directly, but have to be replaced by another sub-tree (statement) or symbol.

\pagebreak{}

\subsection{Reachability}


As mentioned before verification of a node involves comparing the current node against a number of sub-trees.\\ To select the sub-trees the current node is compared against, we have to introduce the concept of \emph{reachability}.


\begin{code}
\captionof{listing}{Example}\label{code:reach1}
\inputminted[linenos]{\prv}{examples/reach1.prove}
\end{code}

\begin{figure}[!h]
\caption{Representation of \scref{reach1}}\label{fig:reach1}
\centering
\includegraphics[width=\textwidth, height=10cm, keepaspectratio]{tikz/reach1.pdf}
\end{figure}

To determine which nodes are reachable from the current node, we go back in the tree node by node moving to the left and upwards. All of these nodes containing statements are reachable from the current node. Further, the following holds:

\begin{itemize}
	\item
		If a reachable statement contains variables, all variables have to be substituted by reachable nodes containing no variables.
	\item
		If a reachable statement contains another statement, that statement is also reachable.
	\item
		If a reachable statement contains an implication, the conclusions of the implication are reachable, when the assumptions can be verified. 
	\item
		If a reachable statement contains an equality, all statements in that equality are reachable, if at least one statement can be verified.
\end{itemize}

The verification of assumptions might depend on the substitution of variables.
\newline

Let us consider \scref{reach1}. Translated to English \scref{reach1} says: There is an identifier \m{a} and there is a property \m{[b]prop}, which can be applied to any variable \m{b}. It follows that \m{a} has this property.
\newline

Now let us understand, how the \name\ code can be verified using the tree from \figref{reach1}: Nodes 0 and 2 and their respective sub-trees are assumptions and do not have to be verified. Node 7 is part of an implication formula and not an assumption -\ in fact is is the only node in the tree, which satisfies these conditions -\ so it has to be verified. The nodes 0 and 2 are the only nodes, which are reachable from node 7. Node 0 is a constant statement (i.e.\ a statement not containing any variables), whereas node 2 is a variable statement. Before attempting to compare node 7 with node 2 the variable has to be substitutes. The variable node in the sub-tree below statement 2 is node number 4 (\m{b}), which is to be replaced by the children of all constant statements (one at a time of course), which are reachable from node 7. In this case the only constant statement, which is reachable from node 7 is statement 0 (\m{[a]}), so we substitute node 4 (\m{b}) by the child of node 0, namely node 1 (\m{a}), before we compare the sub-tree under node 2 (now \m{[a]prop}) against the sub-tree under node 7 (\m{[a]prop}).
\newline

To get deeper insight in how the reachability in sub-trees is determined, let us look at a slightly more involved example.
In \scref{reach2} we make three assumptions: There is an identifier \m{a}, there is a property \m{[b]prop}, which can by applied to any identifier, and if \m{a} has this property, then it also has a second property. In this example the statements 17 and 22 require verification. Statement 17 can like in the previous example be justified by statement 2. For statement 22 however, we have to explore the sub-tree below node 6. Node 6 contains an implication, which depends on the assumption of statement 7, so before we can determine, whether any of the statements in implication 6 are reachable, we have to verify assumption 7. Assumption 7 therefore has to be compared against all constant nodes, which are directly reachable from node 22, namely 17 and 0. It turns out that assumption 7 can be verified using statement 17, which lets us reach statement 12 from node 22, which we intend to verify. Since the statements (\m{[a]prop2}) in node 22 and node 12 are similar, the verification is successful.

Note that without statement 17, statement 22 could currently not be verified, since assumption 7 is compared against all \emph{constant} statements, which are directly reachable from node 22.
\pagebreak{}

\begin{code}
\captionof{listing}{Example}\label{code:reach2}
\inputminted[linenos]{\prv}{examples/reach2.prove}
\end{code}

\begin{figure}[!h]
\caption{Representation of \scref{reach2}}\label{fig:reach2}
\centering
\includegraphics[width=\textwidth, height=15cm, keepaspectratio]{tikz/reach2.pdf}
\end{figure}

\pagebreak{}

\subsection{Negation}
When making a statement it is desirable to be able to express that something is not true. This can be achieved by means of negation. The negation operator \m{!} in the current implementation is not a formulator, but a part of the statement that follows it. A statement, which is negated, is assumed to be false and true otherwise. The effect of verification can therefore be inverted by the negation operator.
Let us modify \scref{var1}, which could not be verified, to see, how this works:

\begin{code}
\captionof{listing}{Example}\label{code:neg1}
\inputminted[linenos]{\prv}{examples/neg1.prove}
\end{code}

\begin{figure}[!h]
\caption{Representation of \scref{neg1}}\label{fig:neg1}
\centering
\includegraphics[width=\textwidth, height=10cm, keepaspectratio]{tikz/neg1.pdf}
\end{figure}

Translated to English \scref{neg1} can be read as follows: There are two variables and a constant identifier \m{c}. Therefore there is not an identifier \m{a}.
\newline

Since the existence of an identifier \m{a} has not been stated before, the statement that there is no such identifier must be true. As opposed to \scref{var1} in \scref{neg1} node 8 carries the \texttt{TRUE} flag.

\pagebreak{}

\begingroup
\setstretch{0.8}
\setlength\bibitemsep{10pt}
\printbibliography\
\endgroup

\end{document}
